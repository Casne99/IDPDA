\documentclass[a4paper,12pt]{report}

\usepackage[utf8]{inputenc}     % Per caratteri accentati
\usepackage[T1]{fontenc}        % Font encoding
\usepackage[italian]{babel}     % Lingua italiana
\usepackage{lmodern}            % Font leggibile
\usepackage{geometry}           % Margini personalizzati
\geometry{margin=3cm}
\usepackage{setspace}           % Spaziatura
\onehalfspacing                 % Interlinea 1.5
\usepackage{graphicx}           % Immagini
\usepackage{float}              % Controllo posizionamento figure
\usepackage{amsmath, amssymb}   % Matematica
\usepackage{amsthm}             % Ambienti per teoremi, definizioni, ecc.
\usepackage{hyperref}           % Link ipertestuali
\usepackage{fancyhdr}           % Intestazioni e piè di pagina
\usepackage{titlesec}           % Formattazione titoli

% Definizione ambiente teorema numerato per capitolo
\newtheorem{theorem}{Teorema}[chapter]
\newtheorem{definition}{Definizione}[chapter]

% Personalizzazione stile proposizione
\newtheoremstyle{propositionstyle}
  {12pt}   % spazio sopra
  {12pt}   % spazio sotto
  {\itshape} % font del corpo
  {0pt}    % indentazione
  {\bfseries} % font dell'intestazione
  {.}      % punteggiatura dopo l'intestazione
  {.5em}   % spazio dopo l'intestazione
  {}       % specifica dell'intestazione

\theoremstyle{propositionstyle}
\newtheorem{prop}{Proposizione}[chapter]


\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}
{}
{0pt}
{\Huge}

% Impostazioni intestazioni
\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\leftmark}
\fancyhead[LO]{\rightmark}

% Frontespizio personalizzabile
\begin{document}

    \begin{titlepage}
        \centering
        {\scshape\LARGE Università degli Studi di Milano \par}
        \vspace{1cm}
        {\scshape\Large Facoltà di Scienze e Tecnologie \par}
        \vspace{0.5cm}
        {\scshape\large Corso di Laurea in Informatica\par}
        \vspace{2cm}
        {\huge\bfseries Input Driven Pushdown Automata ed Edit Distances\par}
        \vspace{2cm}
        \begin{flushleft}
            \textbf{Relatore:} Giovanni Pighizzini\\
            \textbf{Candidato:} Luca Casnedi\\
            \textbf{Matricola:} 931856
        \end{flushleft}
        \vfill
        {\large Anno Accademico 2024--2025\par}
    \end{titlepage}

    \pagenumbering{Roman}
    \tableofcontents
    \clearpage

    \pagenumbering{arabic}

    \chapter{Introduzione}

    Gli \emph{Input Driven Pushdown Automata}, anche detti IDPDA, sono una classe di automi a pila in cui le operazioni sulla pila sono esclusivamente determinate dal simbolo di input.
    In particolare, il simbolo di input determina se l'automa compierà un'operazione di \emph{push} sulla pila, di \emph{pop}, oppure se lascerà la pila invariata.

    Gli IDPDA risultano particolarmente utili in diversi ambiti, tra cui il \emph{parsing} dei linguaggi di programmazione, dei documenti XML e, più in generale, in tutti i contesti in cui la struttura dell'input riflette la struttura gerarchica dei dati.

    È interessante notare come la famiglia dei linguaggi riconosciuti dagli IDPDA mantenga molte delle proprietà tipiche dei linguaggi regolari, pur essendo più ampia.

    Un problema di particolare rilevanza, dove gli IDPDA trovano utilizzo, consiste nel determinare la distanza tra una data stringa $s$ e un linguaggio $L$, detta anche \textit{distanza di edit}.
    Tale distanza è definita come il costo minimo di una sequenza di operazioni elementari di modifica su $s$ (sostituzione, inserimento, eliminazione di un simbolo), che la trasformano in una stringa $s' \in L$.

    In uno scenario applicativo, si può supporre di aver ricevuto in input una stringa appartenente a $L$, la quale potrebbe tuttavia contenere errori.
    L'obiettivo è quindi ricostruire, con la miglior accuratezza possibile, la stringa originaria.

    Per ottenere tale risultato, si può adottare un approccio a \emph{distanza minima}, ovvero determinare la stringa $y \in L$ tale che la \textit{distanza di edit} tra $x$ (la stringa ricevuta) e $y$ sia minima.

    \chapter{Definizioni}

    \section{Notazioni}
    
    Nel seguito, $\Sigma$ denota un alfabeto finito e $\Sigma^*$ è l'insieme delle stringhe su $\Sigma$, $\epsilon$ è la stringa vuota e la lunghezza di una stringa $w \in \Sigma^*$ è $|w|$. Dati gli insiemi $S$ e $T$, l'insieme delle funzioni parziali da $S$ a $T$ è denotato da $T^S$. La cardinalità di un insieme finito $S$ è $|S|$. Il simbolo $\perp$ denota la pila vuota e $2^S$ denota l'insieme delle parti dell'insieme $S$.

    \section{Input Driven Pushdown Automata}

    Una transizione di un IDPDA è determinata dal tipo di simbolo in input, appartenente all'alfabeto $\Sigma$, che stabilisce l'operazione da eseguire, eventualmente nulla.
    
    Si può rappresentare l'alfabeto di input di un IDPDA come unione di tre sottoinsiemi disgiunti e finiti:

    \begin{itemize}
        \item $\Sigma_{+1}$: parentesi sinistre, determinano una operazione di push sulla pila
        \item $\Sigma_{-1}$: parentesi destre, determinano una operazione di pop sulla pila
        \item $\Sigma_{0}$: simboli neutrali, non si traducono in operazioni sulla pila
    \end{itemize}

    Una stringa $s \in \Sigma$ è detta \textit{ben formata} se ogni parentesi sinistra ha una parentesi destra corrispondente, e viceversa.

    \section{Automi Input Driven Deterministici}

    \begin{definition}
        Un \textit{automa a pila input driven deterministico} (detto anche DIDPDA) è una settupla $A = \left(\Sigma, Q, \Gamma, q_0, \perp, \left[ \delta_a \right]_{a \in \Sigma}, F\right)$ dove:
        \begin{itemize}
            \item $\Sigma$ è un alfabeto di input, composto da tre sotto-insiemi finiti e disgiunti $\Sigma_{+1}$, $\Sigma_{-1}$, $\Sigma_{0}$
            \item $Q$ è l'insieme di stati dell'automa
            \item $q_{0} \in Q$ è lo stato iniziale
            \item $F \subseteq Q$ è il sottoinsieme degli stati \textit{accettanti}
            \item $\Gamma$ è  l'\textit{alfabeto della pila}
            \item $\perp$ è il simbolo che indica la pila vuota
            \item $\delta_{<} : Q \rightarrow Q \times \Gamma$ è la funzione di transizione che, per ogni parentesi sinistra $< \in \Sigma_{+1}$, dato un determinato stato corrente, fornisce lo stato successivo ed il simbolo da pushare sulla pila
            \item $\delta_{>} : Q \times \left(\Gamma\;\cup\perp\right) \rightarrow Q$ è la funzione di transizione che, per ogni parentesi destra $> \in \Sigma_{-1}$, dato un determinato stato corrente, fornisce lo stato successivo, posto che il simbolo specificato si trovi in cima alla pila e venga rimosso da essa o lo stack sia vuoto
            \item $\delta_{c} : Q \rightarrow Q$ è la funzione di transizione che, per ogni simbolo neutro $c \in \Sigma_{0}$, fornisce il prossimo stato
        \end{itemize}
    \end{definition}

    Data questa definizione del modello comportamentale di un DIDPDA alla lettura di un simbolo, si può subito notare come il contenuto della pila
    sia preso in considerazione solo quando il simbolo di input è una parentesi destra. 
    
    Quando il simbolo in input è, invece, un simbolo neutro o una parentesi sinistra, il prossimo stato non dipende dal contenuto dello stack.

    \clearpage
    \subsection{Esempio di DIDPDA}
    
    Per illustrare il funzionamento di un automa input driven deterministico, consideriamo il seguente esempio:
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=4.2\textwidth,height=0.6\textheight,keepaspectratio]{img/automa_det}
        \caption{Esempio di automa input driven deterministico}
        \label{fig:esempio_didpda}
    \end{figure}

    Per l'automa rappresentato in Figura~\ref{fig:esempio_didpda}, gli alfabeti sono $\Sigma_{+1} = \{<\}$, $\Sigma_{-1} = \{>\}$, $\Sigma_0 = \emptyset$ e $\Gamma = \{X\}$.
    
    Le funzioni di transizione si possono definire come segue:

    \begin{align}
        \delta_{<}\left(q_0\right) &= \begin{cases}
        \left(q_0, X\right)
        \end{cases} \\[1em]
        \delta_{>}\left(q_0, \gamma\right) &= \begin{cases}
            q_0 & \text{se } \gamma = X \text{ (viene rimosso } X \text{ dalla pila)} \\
            q_{\text{err}} & \text{se } \gamma = \perp \text{ (pila vuota)}
        \end{cases}
    \end{align}

    In questo esempio non compaiono simboli neutrali.
    Questo automa riconosce stringhe come \textit{<}, \textit{<>}, \textit{<{<}<>} ma non riconosce \textit{>}, poiché quest'ultima farebbe transitare l'automa nello stato di errore $q_{\text{err}}$.

    \section{Automi Input Driven non Deterministici}

    \begin{definition}
        Un \textit{automa a pila input driven non deterministico} (detto anche NIDPDA) è una settupla $A = \left(\Sigma, Q, \Gamma, q_0, \perp, \delta, F\right)$ dove:
        \begin{itemize}
            \item $q_{0} \in Q$ è lo stato iniziale
            \item per ogni parentesi sinistra $< \in \Sigma_{+1}$, la funzione di transizione $\delta_{<} : Q \rightarrow 2^{Q \times \Gamma}$ fornisce, dato un certo stato attuale, un insieme di possibili risultati, ovvero coppie che indicano stato successivo e simbolo da caricare sullo stack
            \item per ogni parentesi destra $> \in \Sigma_{-1}$, la funzione di transizione $\delta_{>} : Q \times \left(\Gamma \cup \{\perp\}\right) \rightarrow 2^Q$, dato lo stato attuale e il simbolo in cima alla pila (che sarà rimosso se la pila non è vuota), fornisce un insieme di possibili stati successivi %lo stato successivo se viene effettuata una operazione di pop dallo stack del simbolo corrispondente
            \item per ogni simbolo neutro $c \in \Sigma_{0}$, c'è una funzione $\delta_{0} : Q \rightarrow 2^Q$
            \item l'alfabeto di input $\Sigma$, l'insieme degli stati $Q$, l'alfabeto della pila $\Gamma$, lo stack vuoto $\perp$ e l'insieme degli stati accettanti $F \subseteq Q$ sono definiti come nella Definizione 2.1
        \end{itemize}
    \end{definition}

    Con gli automi non deterministici, la funzione di transizione è calcolata più volte per lo stesso input. 
    
    Una stringa è accettata se almeno una delle computazioni risultanti dalla lettura della stringa termina in uno stato \textit{accettante}.

    \section{Grammatiche Input-Driven}

    Gli Input Driven Pushdown Automata sono stati introdotti durante lo studio di particolari tipi di grammatiche, queste grammatiche sono definite
    con un alfabeto e una serie di regole che danno origine a stringhe che osservano vari criteri di \textit{corretta parentesizzazione}.
    
    Il primo dei modelli studiati sono state le \textit{grammatiche di parentesi} di McNaughton, nel quale l'alfabeto conteneva una parentesi sinistra $<$, una parentesi destra $>$
    ed una serie di simboli terminali, e le regole erano nella forma $X \rightarrow <\alpha>$, con $\alpha \in \left(\Sigma_0 \cup N\right)$ (dove $N$ è l'insieme dei simboli non terminali della grammatica), oppure nella forma $X \rightarrow c$ con $c \in \Sigma_0^*$.
    
    Tutte queste grammatiche vanno a dare origine a sottoclassi dei linguaggi input-driven.

    \begin{definition}
        Una grammatica input-driven è una quadrupla $G = \left(\Sigma, N, R, S\right)$ dove:
        \begin{itemize}
            \item $\Sigma = \Sigma_{-1} \cup \Sigma_0 \cup \Sigma_{+1}$ è l'alfabeto, diviso in tre sottoinsiemi disgiunti
            \item $N$ è l'insieme dei simboli non terminali
            \item $R$ è l'insieme delle regole, ognuna nella forma $A \rightarrow <B>C$, $A \rightarrow aC$, $A \rightarrow \epsilon$, dove $A, B, C \in N$, $< \in \Sigma_{+1}$, $> \in \Sigma_{-1}$, $a \in \Sigma$.
            \item $S$ è il simbolo iniziale
        \end{itemize}
    \end{definition}

    \subsection{Esempio di grammatica input-driven}
    
    Un modello più generale, studiato da Berstel e Boasson, sono le \textit{grammatiche bilanciate}, nelle quali esiste una corrispondenza biunivoca tra parentesi sinistre e destre, in modo che ogni regola $A \rightarrow <\alpha>$ debba utilizzare una coppia di parentesi corrispondenti.
    
    Consideriamo un esempio di grammatica bilanciata con:
    \begin{itemize}
        \item $\Sigma_{+1} = \{<, [\}$
        \item $\Sigma_{-1} = \{>, ]\}$
        \item $\Sigma_0 = \{\beta\}$
        \item $N = \{S, A\}$
    \end{itemize}
    
    Le regole di produzione si possono definire come segue:
    
    \begin{align}
        S &\rightarrow < A > \mid [A] \mid \epsilon \\
        A &\rightarrow < A > \mid [A] \mid \beta
    \end{align}
    
    In questo esempio ogni regola utilizza una coppia di parentesi corrispondenti, rispettando il vincolo delle grammatiche bilanciate. La grammatica genera stringhe come $<\beta>$, $[\beta]$, $<<\beta>>$, $[[\beta]]$, $<[\beta]>$, $[<\beta>]$.

    \section{Distanze di Edit}

    Il problema del calcolare le distanze di edit tra stringhe è strettamente correlato al problema del trovare la stringa con distanza di edit minima rispetto ad una data (correction problem).
    
    Una operazione di edit è una coppia $\left(a, b\right) \neq \left(\epsilon, \epsilon\right)$ con $\lvert a \rvert, \lvert b \rvert \leq 1$, ed è comunemente indicata con
    $a \rightarrow b$. 
    
    Una certa stringa $y$ può essere derivata da un'altra stringa $x$ tramite una operazione di edit $a \rightarrow b$, se $\exists v, w \in \Sigma^* \mid x = vaw, y = vbw$.
    
    Dati $a, b \in \Sigma, a \neq b$, possiamo definire le operazioni $a \rightarrow b$, $a \rightarrow \epsilon$ e $\epsilon \rightarrow a$ rispettivamente
    \textit{sostituzione}, \textit{cancellazione} e \textit{inserimento}.
    
    Ad ogni operazione di edit è associato un costo, rappresentato mediante la funzione $\gamma(a \rightarrow b)$.
    
    Data una sequenza di operazioni di edit $S = \left(s_1, s_2, \dots, s_k\right)$, il costo di $S$ è definito come la somma dei costi delle singole operazioni di edit
    $\sum_{i=1}^{k} \gamma(s_i)$.

    Si assume che dati $x, y, k \in \left(\Sigma \cup \epsilon\right)$, $\gamma\left(x \rightarrow y\right) = 0$ se e solo se $x = y$, e $\gamma\left(x \rightarrow y\right)
    + \gamma\left(y \rightarrow k\right) \geq \gamma\left(x \rightarrow k\right)$.

    \begin{definition}
        Date due stringhe $x, y \in \Sigma^*$, la distanza di edit $d\left(x, y\right)$ da $x$ a $y$ è il minimo dei costi delle sequenze di operazioni di edit che trasformano $x$ in $y$.
    \end{definition}
    
    Ad esempio, sia $\Sigma = \{i, j\}$ e $\gamma\left(a \rightarrow b\right) = 1$ per ogni $a, b \in \Sigma \cup \{\epsilon\}$ con $a \neq b$. Per trasformare la stringa $iji$ nella stringa $jj$ si può utilizzare la seguente sequenza di operazioni:
    
    $$iji \xrightarrow{i \rightarrow j} jji \xrightarrow{i \rightarrow \epsilon} jj$$
    
    In questo caso sono state utilizzate una sostituzione e una cancellazione, per un costo totale di $1 + 1 = 2$.

    Questa definizione di distanza si può estendere, fissando un concetto di distanza che non riguarda due stringhe ma bensì una stringa e un linguaggio.

    \begin{definition}
        La distanza di edit tra un linguaggio $L \subseteq \Sigma^*$ ed una stringa $x \in \Sigma^*$ è il minimo tra i costi delle sequenze di operazioni di edit
        che trasformano stringhe di $L$ in $x$, ovvero $d\left(L, x\right) = \min\left\{d\left(y, x\right) \mid y \in L \right\}$.
    \end{definition}

    Fissato un linguaggio $L \subseteq \Sigma^*$, la funzione $d\left(L, x\right)$ nella variabile $x$ viene denominata \textit{distanza di edit del linguaggio} $L$.

    \subsection{Esempi di distanze}
    
    Esistono diverse varianti della distanza di edit, che differiscono per le operazioni consentite e i relativi costi. Di seguito presentiamo due delle più comuni.
    
    \subsubsection{Distanza di Hamming}
    
    La \textit{distanza di Hamming} è definita solo per stringhe di uguale lunghezza e considera esclusivamente operazioni di sostituzione. Formalmente, date due stringhe $x, y \in \Sigma^*$ con $|x| = |y| = n$, la distanza di Hamming è:
    
    $$d_H\left(x, y\right) = \left|\left\{i \in \left[1, n\right] : x\left[i\right] \neq y\left[i\right]\right\}\right|$$
    
    dove $x\left[i\right]$ e $y\left[i\right]$ denotano l'$i$-esimo carattere delle stringhe $x$ e $y$ rispettivamente. In altre parole, la distanza di Hamming conta il numero di posizioni in cui i caratteri corrispondenti sono diversi.

    \subsection{Calcolo delle distanze di edit}

    Date due stringhe, la distanza di edit tra di esse può essere determinata in termini di distanza tra le loro sottostringhe.

\begin{prop}
    Siano $u,v,w,z \in \Sigma^*$. Allora vale
    \[
        d\left(uv, wz\right) \leq d\left(u,w\right) + d\left(v,z\right).
    \]
\end{prop}

\begin{proof}
    Per definizione, $d\left(u,w\right)$ è il costo minimo necessario per trasformare $u$ in $w$, mentre $d\left(v,z\right)$ è il costo minimo per trasformare $v$ in $z$.
    Consideriamo dunque la seguente strategia:
    \begin{enumerate}
        \item trasformiamo $u$ in $w$ mediante una sequenza ottimale di operazioni, al costo $d\left(u,w\right)$;
        \item trasformiamo $v$ in $z$ mediante una sequenza ottimale di operazioni, al costo $d\left(v,z\right)$.
    \end{enumerate}
    Applicando queste trasformazioni in sequenza, otteniamo una trasformazione da $uv$ a $wz$ con costo totale pari a $d\left(u,w\right)+d\left(v,z\right)$.

    Poiché la distanza $d\left(uv,wz\right)$ è definita come il costo minimo tra tutte le possibili trasformazioni, segue immediatamente che
    \[
        d\left(uv, wz\right) \leq d\left(u,w\right) + d\left(v,z\right). \qedhere
    \]
\end{proof}

\begin{prop}
    Per ogni $x', x'', y \in \Sigma^*$ vale:
    \[
        d\left(x'x'', y\right) = \min\left\{d\left(x', y'\right) + d\left(x'', y''\right) \mid y = y'y''\right\}.
    \]
\end{prop}

    \begin{proof}
        Definiamo il minimo cercato:
        \[
            M := \min\left\{d\left(x', y'\right) + d\left(x'', y''\right) \mid y = y'y''\right\}.
        \]

        \textbf{(1)} Mostriamo che $d\left(x'x'', y\right) \leq M$.

        Prendiamo una decomposizione $y = y'y''$ che realizza (o approssima) il minimo $M$. Trasformiamo $x'$ in $y'$ con una sequenza ottimale di costo $d\left(x', y'\right)$ e trasformiamo $x''$ in $y''$ con una sequenza ottimale di costo $d\left(x'', y''\right)$.
        Concatenando le due trasformazioni otteniamo una trasformazione da $x'x''$ a $y$, di costo totale $d\left(x', y'\right) + d\left(x'', y''\right) = M$.
        Poiché $d\left(x'x'', y\right)$ è definito come il costo minimo, si ha $d\left(x'x'', y\right) \leq M$.

        \vspace{0.5em}

        \textbf{(2)} Mostriamo che $d\left(x'x'', y\right) \geq M$.

        Sia $\tau$ una sequenza ottimale di trasformazioni che porta $x'x''$ in $y$.
        Durante questa trasformazione, la parte iniziale $x'$ viene consumata e produrrà un certo prefisso $y'$ di $y$.
        La parte rimanente $x''$ sarà trasformata nel suffisso $y''$, con $y = y'y''$.
        Il costo totale di $\tau$ si può allora suddividere: una parte è dovuta alla trasformazione di $x'$ in $y'$, e l'altra alla trasformazione di $x''$ in $y''$.
        Quindi il costo $d\left(x'x'', y\right)$ è almeno $d\left(x', y'\right) + d\left(x'', y''\right)$.
        Questo vale per quella specifica decomposizione di $y$, quindi a maggior ragione vale per il minimo su tutte: $d\left(x'x'', y\right) \geq M$.

        \vspace{0.5em}

        \textbf{Conclusione.} Dalle due disuguaglianze otteniamo l'uguaglianza: $d\left(x'x'', y\right) = M$.
    \end{proof}

    Si può inoltre individuare facilmente un limite superiore per il calcolo della distanza di edit
    tra un linguaggio $L$ ed una stringa $x \in \Sigma^*$.

    \begin{prop}\label{prop:distanza-limitata}
        Dato un linguaggio $L \in \Sigma^*$ ed una funzione di costo $\gamma$ esistono costanti $\alpha, \beta$ tali che
        $d\left(L, x\right) \leq \alpha \lvert x \rvert + \beta$
    \end{prop}

    \begin{proof}
        Scegliamo una stringa $z \in L$, allora $d\left(L, x\right) \leq d\left(z, x\right)$.
        Si può inoltre trasformare $z$ in $x$ contatenando $z$ con $x$ e cancellando in seguito $z$ dalla stringa risultante:

        $$\displaystyle d\left(L, x\right) \leq d\left(z, x\right) \leq \sum_{i=1}^{\lvert x \rvert} \gamma\left(\epsilon \rightarrow x_i\right) + \sum_{i=1}^{\lvert z \rvert} \gamma\left(z_i \rightarrow \epsilon\right) \leq \alpha \lvert x \rvert + \beta$$

        In questo caso, $\alpha = \max\left\{\gamma\left(\epsilon \rightarrow b\right) \mid b \in \Sigma\right\}$ e $\beta = \sum_{i=1}^{\lvert z \rvert} \gamma\left(z_i \rightarrow \epsilon\right)$
    \end{proof}

    Partendo da questo risultato, si possono individuare stringhe di $L$ che minimizzano questa distanza.

    \begin{prop}
        Dato un linguaggio $L \in \Sigma^*$ ed una funzione di costo $\gamma$ esistono costanti $\alpha', \beta'$ tali che
        $\forall{x \in \Sigma^*}, \forall{y \in L}$ tali che $d\left(L, x\right) = d\left(y, x\right)$ vale $\lvert y \rvert \leq \alpha' \lvert x \rvert + \beta'$
    \end{prop}

    \begin{proof}
        Scegliamo $y \in L$ tale che $d\left(L, x\right) = d\left(y, x\right)$ e definiamo $\lambda$ come il minimo tra i costi degli inserimenti e delle cancellazioni:

        $$ \lambda = \min\bigl\{\{\gamma\left(\epsilon \rightarrow c\right) \mid c \in \Sigma\} \cup \{\gamma\left(c \rightarrow \epsilon\right) \mid c \in \Sigma\}\bigr\}$$

        Si può affermare che per derivare una stringa $y$ da una stringa $x$, si dovranno effettuare operazioni di cancellazione o inserimento in numero pari
        ad almeno la differenza in lunghezza tra le due stringhe, segue quindi che $d\left(y, x\right) \geq \lambda\bigl|\left(\lvert y \rvert - \lvert x \rvert\right)\bigr|$.
        Si può quindi esprimere la disuguaglianza in termini di $y$:

        $$\lvert y \rvert \leq \lvert x \rvert + \frac{1}{\lambda}d\left(y, x\right)$$

        Senza perdita di generalità si può assumere $\lvert y \rvert - \lvert x \rvert \geq 0$.

        Usando la Proposizione~\ref{prop:distanza-limitata} e ricordando che $d\left(L, x\right) = d\left(y, x\right)$ otteniamo:

        $$\lvert y \rvert \leq \left(\frac{\alpha}{\lambda} + 1\right)\lvert x \rvert + \frac{\beta}{\lambda}$$


    \end{proof}


    \section{Conclusioni}

    Osservazioni finali e possibili sviluppi futuri\ldots

    \clearpage
    \begin{thebibliography}{9}

        \bibitem{okhotin-salomaa}
        Alexander Okhotin, Kai Salomaa,
        \textit{Complexity of Input-Driven Pushdown Automata}.

        \bibitem{pighizzini}
        Giovanni Pighizzini,
        \textit{How Hard Is Computing the Edit Distance?}

% Aggiungere altre fonti

    \end{thebibliography}

\end{document}
